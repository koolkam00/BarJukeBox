// @ts-nocheck
import { Hono } from 'npm:hono'
import { logger } from 'npm:hono/logger'
import { cors } from 'npm:hono/cors'
import { createClient } from 'npm:@supabase/supabase-js'
import * as kv from './kv_store.ts'

const app = new Hono()

app.use('*', cors({ origin: '*', allowMethods: ['GET','POST','PUT','DELETE','OPTIONS'], allowHeaders: ['*'] }))
app.use('*', logger(console.log))

const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  (Deno.env.get('SERVICE_ROLE_KEY') || Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'))!
)

interface Song { id: string; title: string; artist: string; duration: number; artwork?: string; genre?: string }
interface QueueItem { id: string; songId: string; song: Song; userId: string; sessionId: string; position: number; dedication?: string; boosted?: boolean; tip?: number; createdAt: string; status: 'queued'|'playing'|'played' }
interface Session { id: string; barName: string; isOpen: boolean; pricePerSong: number; maxSongLength: number; explicitFilter: boolean; avgWaitTime: number; ownerId?: string; nowPlaying?: QueueItem }

const generateId = () => crypto.randomUUID()

app.get('/', (c)=>c.json({ ok:true }))
app.get('/health', (c)=>c.json({ status:'ok' }))

app.get('/session/:sessionId', async (c)=>{ try { const id=c.req.param('sessionId'); const s=await kv.get(`session:${id}`); if(!s) return c.json({error:'Session not found'},404); return c.json(s) } catch(e){ return c.json({error:'Failed to fetch session'},500)} })
app.post('/session', async (c)=>{ try { const { barName, pricePerSong=3, maxSongLength=300, explicitFilter=true } = await c.req.json(); let ownerId: string|undefined; const auth=c.req.header('Authorization'); if(auth){ const token=auth.split(' ')[1]; const { data:{user} }=await supabase.auth.getUser(token); if(user?.id) ownerId=user.id } const id=generateId(); const session: Session={ id, barName, isOpen:true, pricePerSong, maxSongLength, explicitFilter, avgWaitTime:180, ownerId }; await kv.set(`session:${id}`,session); await kv.set(`queue:${id}`,[]); return c.json({session}) } catch(e){ return c.json({error:'Failed to create session'},500)} })
app.get('/sessions/active', async (c)=>{ try { const sessions=(await kv.getByPrefix('session:')) as Session[]; const active=(sessions||[]).filter(s=>s?.isOpen); return c.json(active.map(s=>({id:s.id,barName:s.barName,isOpen:s.isOpen,pricePerSong:s.pricePerSong}))) } catch(e){ return c.json({error:'Failed to list sessions'},500)} })
app.get('/queue/:sessionId', async (c)=>{ try { const id=c.req.param('sessionId'); const q=await kv.get(`queue:${id}`)||[]; return c.json(q) } catch(e){ return c.json({error:'Failed to fetch queue'},500)} })
app.post('/queue/:sessionId/add', async (c)=>{ try { const id=c.req.param('sessionId'); const { songId, song, userId, dedication, tip }=await c.req.json(); const session=await kv.get(`session:${id}`); if(!session||!session.isOpen) return c.json({error:'Session not available'},400); const q=await kv.get(`queue:${id}`)||[]; const dup=q.find((it:any)=>it.songId===songId && it.status==='queued'); if(dup) return c.json({error:'Song already in queue'},400); const item: QueueItem={ id:generateId(), songId, song, userId, sessionId:id, position:q.length, dedication, boosted: tip>0, tip, createdAt:new Date().toISOString(), status:'queued' }; if(tip&&tip>0){ const pos=Math.max(0,Math.floor(q.length/2)); q.splice(pos,0,item); q.forEach((it:any,i:number)=>it.position=i) } else q.push(item); await kv.set(`queue:${id}`,q); const eta=q.length * (session.avgWaitTime/Math.max(1,q.length)); return c.json({ queueItem:item, position:item.position+1, eta:Math.round(eta) }) } catch(e){ return c.json({error:'Failed to add song to queue'},500)} })
app.post('/admin/login', async (c)=>{ try { const {email,password}=await c.req.json(); const {data,error}=await supabase.auth.signInWithPassword({email,password}); if(error||!data.session) return c.json({error:'Invalid credentials'},401); return c.json({accessToken:data.session.access_token,user:data.user}) } catch(e){ return c.json({error:'Login failed'},500)} })
app.post('/admin/register', async (c)=>{ try { const {email,password,barName,username}=await c.req.json(); if(!email||!password||!barName||!username) return c.json({error:'Email, password, barName and username required'},400); let token:string|null=null; let uid:string|null=null; try { const { error:ce }=await supabase.auth.admin.createUser({email,password,email_confirm:true}); if(ce){ const m=String(ce.message||''); if(!m.toLowerCase().includes('already')) return c.json({error:ce.message},400) } const {data, error}=await supabase.auth.signInWithPassword({email,password}); if(error||!data.session) return c.json({error:'Registration succeeded but login failed'},400); token=data.session.access_token; uid=data.user.id } catch(_) { token=`dev:${email}`; uid=`dev-${btoa(email)}` }
  const ownerId=uid!; const sessionId=generateId(); const session: Session={ id:sessionId, barName, isOpen:true, pricePerSong:3, maxSongLength:300, explicitFilter:true, avgWaitTime:180, ownerId }; await kv.set(`session:${sessionId}`,session); await kv.set(`queue:${sessionId}`,[]); await kv.set(`filters:${ownerId}:providers`,{spotify:true,apple:true}); await kv.set(`admin:${ownerId}:profile`,{username,barName}); return c.json({accessToken:token,user:{id:ownerId,email},session}) } catch(e){ return c.json({error:'Registration failed'},500)} })
app.post('/admin/queue/:sessionId/skip', async (c)=>{ try { const access=c.req.header('Authorization')?.split(' ')[1]; const {data:{user}}=await supabase.auth.getUser(access); if(!user?.id) return c.json({error:'Unauthorized'},401); const id=c.req.param('sessionId'); const q=await kv.get(`queue:${id}`)||[]; if(q.length>0){ const np=q.shift(); if(np) np.status='played'; q.forEach((it:any,i:number)=>it.position=i); await kv.set(`queue:${id}`,q) } return c.json({success:true,queue:q}) } catch(e){ return c.json({error:'Failed to skip song'},500)} })
app.get('/search', async (c)=>{ try { const q=c.req.query('q')||''; const provider=(c.req.query('provider')||'all').toLowerCase(); const sessionIdParam=c.req.query('sessionId')||''; const filter=provider==='all'?['spotify','apple']:[provider]; let ownerId: string|undefined; if(sessionIdParam){ const s=await kv.get(`session:${sessionIdParam}`) as Session|null; ownerId=s?.ownerId } const prefix=ownerId?`filters:${ownerId}`:'filters'; const providers=await kv.get(`${prefix}:providers`)||{spotify:true,apple:true}; let results: Song[]=[]; const mock: Song[]=[{id:'mock:1',title:'Bohemian Rhapsody',artist:'Queen',duration:355,genre:'Rock',artwork:'https://picsum.photos/300/300?random=1'}]; if(providers.spotify && filter.includes('spotify')){ const id=Deno.env.get('SPOTIFY_CLIENT_ID'); const secret=Deno.env.get('SPOTIFY_CLIENT_SECRET'); if(id&&secret&&q){ try { const t=await fetch('https://accounts.spotify.com/api/token',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded','Authorization':'Basic '+btoa(`${id}:${secret}`)},body:new URLSearchParams({grant_type:'client_credentials'})}); if(t.ok){ const j=await t.json(); const r=await fetch(`https://api.spotify.com/v1/search?type=track&limit=20&q=${encodeURIComponent(q)}`,{headers:{'Authorization':`Bearer ${j.access_token}`}}); if(r.ok){ const jj=await r.json(); const tracks=jj.tracks?.items||[]; const ts=(ms:number)=>Math.round((ms||0)/1000); results=results.concat(tracks.map((t:any)=>({id:`spotify:${t.id}`,title:t.name,artist:t.artists?.[0]?.name||'Unknown',duration:ts(t.duration_ms),artwork:t.album?.images?.[0]?.url}))) } } } catch(_) { if(results.length===0) results=results.concat(mock) } } else if(results.length===0) results=results.concat(mock) }
  if(providers.apple && filter.includes('apple')){ const dev=Deno.env.get('APPLE_MUSIC_DEVELOPER_TOKEN'); if(dev&&q){ try { const r=await fetch(`https://api.music.apple.com/v1/catalog/us/search?term=${encodeURIComponent(q)}&types=songs&limit=20`,{headers:{'Authorization':`Bearer ${dev}`}}); if(r.ok){ const jj=await r.json(); const songs=jj.results?.songs?.data||[]; const ts=(ms:number)=>Math.round((ms||0)/1000); results=results.concat(songs.map((s:any)=>{ const art=s.attributes?.artwork; const url=art?.url?art.url.replace('{w}x{h}','300x300'):undefined; return {id:`apple:${s.id}`,title:s.attributes?.name||'Unknown',artist:s.attributes?.artistName||'Unknown',duration:ts(s.attributes?.durationInMillis||0),artwork:url}})) } } catch(_) { if(results.length===0) results=results.concat(mock) } } else if(results.length===0) results=results.concat(mock) }
  const allowArtists: string[]=(await kv.get(`${prefix}:allow:artists`))||[]; const blockArtists: string[]=(await kv.get(`${prefix}:block:artists`))||[]; const allowSongs: string[]=(await kv.get(`${prefix}:allow:songs`))||[]; const blockSongs: string[]=(await kv.get(`${prefix}:block:songs`))||[]; const blockGenres: string[]=(await kv.get(`${prefix}:block:genres`))||[]; const ci=(s:string)=>s.toLowerCase(); const inList=(v:string,l:string[])=>l.some(x=>ci(v).includes(ci(x))); let filtered=results; if(allowArtists.length>0) filtered=filtered.filter(s=>inList(s.artist,allowArtists)); if(allowSongs.length>0) filtered=filtered.filter(s=>inList(s.title,allowSongs)); if(blockArtists.length>0) filtered=filtered.filter(s=>!inList(s.artist,blockArtists)); if(blockSongs.length>0) filtered=filtered.filter(s=>!inList(s.title,blockSongs)); if(blockGenres.length>0) filtered=filtered.filter((s:any)=>!s.genre || !inList(s.genre,blockGenres)); const seen=new Set<string>(); const unique: Song[]=[]; for(const s of filtered){ const key=`${ci(s.title)}|${ci(s.artist)}`; if(!seen.has(key)){ seen.add(key); unique.push(s) } if(unique.length>=25) break } return c.json(unique) } catch(e){ return c.json({error:'Search failed'},500)} })
app.get('/filters', async (c)=>{ try { const token=c.req.header('Authorization')?.split(' ')[1]; const {data:{user}}=await supabase.auth.getUser(token); if(!user?.id) return c.json({error:'Unauthorized'},401); const uid=user.id; const providers=await kv.get(`filters:${uid}:providers`)||{spotify:true,apple:true}; const allowArtists=await kv.get(`filters:${uid}:allow:artists`)||[]; const blockArtists=await kv.get(`filters:${uid}:block:artists`)||[]; const allowSongs=await kv.get(`filters:${uid}:allow:songs`)||[]; const blockSongs=await kv.get(`filters:${uid}:block:songs`)||[]; const blockGenres=await kv.get(`filters:${uid}:block:genres`)||[]; return c.json({providers,allowArtists,blockArtists,allowSongs,blockSongs,blockGenres}) } catch(e){ return c.json({error:'Failed to fetch filters'},500)} })
app.post('/filters', async (c)=>{ try { const token=c.req.header('Authorization')?.split(' ')[1]; const {data:{user}}=await supabase.auth.getUser(token); if(!user?.id) return c.json({error:'Unauthorized'},401); const body=await c.req.json(); await kv.set(`filters:${user.id}:providers`, body.providers ?? {spotify:true,apple:true}); await kv.set(`filters:${user.id}:allow:artists`, body.allowArtists ?? []); await kv.set(`filters:${user.id}:block:artists`, body.blockArtists ?? []); await kv.set(`filters:${user.id}:allow:songs`, body.allowSongs ?? []); await kv.set(`filters:${user.id}:block:songs`, body.blockSongs ?? []); await kv.set(`filters:${user.id}:block:genres`, body.blockGenres ?? []); return c.json({success:true}) } catch(e){ return c.json({error:'Failed to update filters'},500)} })

Deno.serve(app.fetch)


